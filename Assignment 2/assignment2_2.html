
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>DCS - 2.2</title>

    <!--- Math.js library, for matrix manipulation, and many other things--->
    <script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js></script>
</head>

<body>

<h1>DCS - 2.2 Properties of conics</h1>

<canvas id="canvas1" height="600" width="600" class="bezier"  style="border:1px solid #d3d3d3;"></canvas>
<br>
<button type="button" onclick="doReset()">Reset</button>
<button type="button" onclick="computeConic()">Draw some conic</button>


<script type="text/javascript">

    /*
    * Part of this code is based on:
        * http://blogs.sitepoint.com/html5-canvas-draw-quadratic-curves/
        * http://blogs.sitepoint.com/html5-canvas-draw-bezier-curves/
    */

    var canvas1, context1, points, myTransformation, style, drag = null, draggedPoint;
    var tolerance = 0.001;

    // TODO replace these points but those of the corresponding conic function (on-the-fly)
    points = [{ x:0, y:0 }];

    function init() {

        myTransformation = function(p){return p}; //Identity transform

        // default styles
        style = {
            curve:	{ width: 6, color: "#333" },
            line:	{ width: 1, color: "#C00" },
            point: { radius: 10, width: 2, color: "#900", fill: "rgba(200,200,200,0.5)", arc1: 0, arc2: 2 * Math.PI }
        }

        // line style defaults
        context1.lineCap = "round";
        context1.lineJoin = "round";

        // Translate origin to center of canvas
        context1.translate(canvas1.width/2,canvas1.height/2);
		
		// Flip y-axis, so it looks like in standard math axes
		context1.scale(1,-1) // Reversed y-axis

        drawCanvas();
    }


    /**
     Basic drawing methods
     **/


    // draw canvas
    function drawCanvas() {
        // Clear everything
        context1.clearRect(0, 0, canvas1.width, canvas1.height);  // Clear canvas

        // Background grids
        drawGrid(context1,canvas1.width, canvas1.height); // Draw background grid

        // Original points and vertices
        drawCurve(context1, style, points); // Draw curve
        drawVertices(context1, style, points); // Draw vertices as circles

    }


    // Draw a background grid
    function drawGrid(myContext,bw,bh){
        var delta = 50; // grid cell size

        var half_width = bw/2;
        var half_height = bh/2;
        for (var x = -half_width; x <= half_width; x += delta) {
            myContext.moveTo(x, -half_height);
            myContext.lineTo(x, half_height);
        }

        for (var y = -half_height; y <= half_height; y += delta) {
            myContext.moveTo(-half_width, y);
            myContext.lineTo(half_width , y);
        }

        myContext.lineWidth = 1;
        myContext.strokeStyle = "lightgray";
        myContext.stroke();

   

    }

    // Draws a polygonal curve connecting the points, after applying the given transformation
    function drawCurve(ctx, style, points, transformation) {
        // The transformation is optional. If none provided, use identity transform
        if (transformation===undefined) {
            transformation = function(p){return p}; //Identity transform
        }

        // Draw curve
        ctx.lineWidth = style.curve.width;
        ctx.strokeStyle = style.curve.color;
        ctx.beginPath();
        var firstPoint = transformation(points[0]);
        var currentPoint;
        ctx.moveTo(firstPoint.x, firstPoint.y);
        for (var i = 0; i < points.length; i++) {
            currentPoint =  transformation(points[i]);
            ctx.lineTo(currentPoint.x, currentPoint.y);
            ctx.moveTo(currentPoint.x, currentPoint.y);
        }
        ctx.stroke();
    }

    // Draw circles around vertices to facilitate drag and drop
    function drawVertices (ctx, style, points) {
        for (var i = 0; i < points.length; i++) {
            var p = points[i];
            ctx.lineWidth = style.point.width;
            ctx.strokeStyle = style.point.color;
            ctx.fillStyle = style.point.fill;
            ctx.beginPath();
            ctx.arc(p.x, p.y, style.point.radius, style.point.arc1, style.point.arc2, true);
            ctx.fill();
            ctx.stroke();
        }
    }
    
    //Draw a vector (passed as two points in space)
    /*
    style = {
        line : {
            color : "#FCFCFC", / "rgba(200,200,200,0.5)"
            width : 1
        },
        tip : {
            color : "#FCFCFC",
            width : 3,
            length : 10
            angle : Math.PI / 6
        }
    }
    */
    function drawVector (ctx, style, vector) {
        var dx = vector[1].x - vector[0].x;
        var dy = vector[1].y - vector[0].y;
        var angle = Math.atan2(dx, dy);
        
        //Draw line
        context.beginPath();
        context.moveTo(vector[0].x, vector[0].y);
        context.lineTo(vector[1].x, vector[1].y);
        context.strokeStyle = style.line.color;
        context.lineWidth = style.line.width;
        context.stroke();
        
        //Draw tip
        context.beginPath();
        context.moveTo( vector[1].x - style.tip.length * Math.cos(angle - style.tip.angle), 
                        vector[1].y - style.tip.length * Math.sin(angle - style.tip.angle));
        context.lineTo(vector[1].x, vector[1].y);
        context.lineTo( vector[1].x - style.tip.length * Math.cos(angle + style.tip.angle), 
                        vector[1].y - style.tip.length * Math.sin(angle + style.tip.angle));
        context.strokeStyle = style.tip.color;
        context.lineWidth = style.tip.width;
        context.stroke();
    }
    
    // Intersection of two lines. If they are parallel or coincident, returns undefined
    /*
    line = {
        x : 15, //x position of the guide point
        y : 5,  //y position of the guide point
        a : Math.PI / 2  //angle of the line (in rad)
    }
    */
    function lineIntersection(line1, line2) {
        var norm_a1 = line1.a % Math.PI;
        var norm_a2 = line2.a % Math.PI;
        if ((Math.max(norm_a1, norm_a2) - Math.min(norm_a1, norm_a2)) < tolerance) return undefined; //Check if parallel or coincident
        var u1 = Math.cos(line1.a);
        var v1 = Math.cos(line2.a);
        var u2 = Math.sin(line1.a);
        var v2 = Math.sin(line2.a);
        var numerator = (line1.y - line2.y) * u1 + (line2.x - line1.x) * u2;
        var denominator = (v2 * u1) - (v1 * u2);
        var lambda = numerator / denominator;
        return {
            x: line2.x + lambda * v1,
            y: line2.y + lambda * v2
        }
    }
    
    //Checks if a point is in a segment
    /*
    point = {
        x : 15,
        y : 5
    }
    */
    function checkInSegment (point, origin, end) {
        var dy_point = (point.y - origin.y);
        var dy_end = (end.y - origin.y);
        var dx_point = (point.x - origin.x);
        var dx_end = (end.x - origin.x);
        var dx_dy_1 = dy_point * dx_end;
        var dx_dy_2 = dy_end * dx_point;
        return ((Math.max(dx_dy_1, dx_dy_2) - Math.min(dx_dy_1, dx_dy_2)) < tolerance);
    }
    
    //Draw a line that collides with a bounding box (only draw a segment inside a box)
    /*
    line = {
        x : 15,
        y : 5,
        a : Math.PI / 2 (rad)
    }
    center = {
        x : 15,
        y : 5
    }
    box = {
        width = 640,
        height = 480
    }
    */
    function drawLine (context, center, box, line) {
        var half_width = box.width / 2;
        var half_height = box.height / 2;

        var norm_a = line.a % Math.PI;
        
        var top_intersect = lineIntersection(line, { x: center.x, y: center.y - half_height, a: 0 });
        var bot_intersect = lineIntersection(line, { x: center.x, y: center.y + half_height, a:0 });
        var left_intersect = lineIntersection(line, { x: center.x - half_width, y: center.y, a: Math.PI });
        var right_intersect = lineIntersection(line, { x: center.x + half_width, y: center.y, a: Math.PI });
        
        if ((top_intersect == undefined) || (bot_intersect == undefined)) drawSegment(context, left_intersect, right_intersect);
        else if ((left_intersect == undefined) || (right_intersect == undefined)) drawSegment(context, top_intersect, bot_intersect);
        else {
            var points = [];
            var top_left = { x: center.x - half_width, y: center.y - half_height };
            var top_right = { x: center.x + half_width, y: center.y - half_height };
            var bot_left = { x: center.x - half_width, y: center.y + half_height };
            var bot_right = { x: center.x + half_width, y: center.y + half_height };
            if (norm_a < (Math.PI) / 2) {
                if (checkInSegment(left_intersect, top_left, bot_left)) points.push(left_intersect);
                else points.push(bot_intersect);
                if (checkInSegment(top_intersect, top_left, top_right)) points.push(top_intersect);
                else points.push(right_intersect);
            } else {
                if (checkInSegment(left_intersect, top_left, bot_left)) points.push(left_intersect);
                else points.push(top_intersect);
                if (checkInSegment(bot_intersect, bot_left, bot_right)) points.push(bot_intersect);
                else points.push(right_intersect);
            }
            drawSegment(context, points[0], points[1]);
        }
    }


    /**
     * Start ("main method")
     */

    // Assign canvas and context variables
    canvas1 = document.getElementById("canvas1");
    context1 = canvas1.getContext("2d");

    init();

    /**
     * Auxiliary functions
     */


    function doReset () {
        myTransformation = function(p){return p}; //Identity transform
        drawCanvas();
    }

    // This is just an example
    function computeConic() {
        // to something
        alert('Code to be written!');
        drawCanvas();
    }

</script>
</body>
</html>
